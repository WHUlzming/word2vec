compile  (  "OneWayNode.java"  ,  "// @(#) $Id: Iterator.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author: Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "interface Iterator { \n"  +  "\n"  +  "  //@ public model instance Object uniteratedElems;\n"  +  "  //@ public model instance nullable Object currElem;\n"  +  "  //@ public model instance boolean unchanged;\n"  +  "\n"  +  "  /*@ public instance invariant currElem == null;\n"  +  "    @*/\n"  +  "\n"  +  "  /*@  public normal_behavior\n"  +  "    @    requires unchanged && !isDone();\n"  +  "    @*/\n"  +  "  public void next();\n"  +  "\n"  +  "  /*@  public normal_behavior\n"  +  "    @    requires unchanged;\n"  +  "    @    assignable \\nothing;\n"  +  "    @*/\n"  +  "  public /*@ pure @*/ boolean isDone();\n"  +  "\n"  +  "  /*@  public normal_behavior\n"  +  "    @    requires unchanged && !isDone();\n"  +  "    @    assignable \\nothing;\n"  +  "    @    ensures \\result == currElem;\n"  +  "    @*/\n"  +  "  public /*@ pure nullable @*/ Object currentItem();\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: RestartableIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author: Clyde Ruby\n"  +  "\n"  +  "interface RestartableIterator extends Iterator {\n"  +  "\n"  +  "    /*@ public model instance Object iteratedElems;\n"  +  "      @*/\n"  +  "\n"  +  "  /*@\n"  +  "    @  public normal_behavior\n"  +  "    @    requires unchanged;\n"  +  "    @    assignable iteratedElems, currElem, uniteratedElems;\n"  +  "  public void first();\n"  +  "\n"  +  "  /*@\n"  +  "    @ also\n"  +  "    @  public normal_behavior\n"  +  "    @    requires unchanged && !isDone();\n"  +  "    @    assignable iteratedElems;\n"  +  "    @*/\n"  +  "  public void next();\n"  +  "\n"  +  "  /*@\n"  +  "    @ also\n"  +  "    @  public normal_behavior\n"  +  "    @    requires unchanged;\n"  +  "    @    assignable \\nothing;\n"  +  "    @*/\n"  +  "  public /*@ pure @*/ boolean isDone();\n"  +  "\n"  +  "}\n"  +  "// @(#) $Id: OneWayNode.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "public class OneWayNode { // Singly Linked Node\n"  +  "\n"  +  "    // data members\n"  +  "\n"  +  "    protected /*@ nullable @*/ Object entry_;\n"  +  "    protected /*@ nullable @*/ OneWayNode nextNode_;\n"  +  "\n"  +  "    // methods\n"  +  "\n"  +  "    public OneWayNode() {\n"  +  "	entry_ = null;\n"  +  "	nextNode_ = null;\n"  +  "    }\n"  +  "    public OneWayNode(/*@ nullable @*/ Object ent) {\n"  +  "	entry_ = ent;\n"  +  "	nextNode_ = null;\n"  +  "    }\n"  +  "    public /*@ pure nullable @*/ Object getEntry() {\n"  +  "	return entry_;\n"  +  "    }\n"  +  "    public void setEntry(/*@ nullable @*/ Object newEntry) {\n"  +  "	entry_ = newEntry;\n"  +  "    }\n"  +  "    public /*@ pure nullable @*/ /* rep */ OneWayNode getNextNode() {\n"  +  "	return nextNode_;\n"  +  "    }\n"  +  "    public void insertAfter(/*@ nullable @*/ Object newEntry) {\n"  +  "	nextNode_ = new OneWayNode(newEntry, nextNode_);\n"  +  "    }\n"  +  "    public void removeNextNode() {\n"  +  "	if (nextNode_ != null) {\n"  +  "	    nextNode_ = nextNode_.getNextNode();\n"  +  "	}\n"  +  "    }\n"  +  "    public boolean hasNext() {\n"  +  "	return nextNode_ != null;\n"  +  "    }\n"  +  "    public /* unaliased */ Object clone() {\n"  +  "	if (nextNode_ == null) {\n"  +  "	    return new OneWayNode(getEntry());\n"  +  "	} else {\n"  +  "	    return new OneWayNode(getEntry(), \n"  +  "				  (OneWayNode)nextNode_.clone());\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ pure @*/ String toString() {\n"  +  "	return stringOfEntries(this);\n"  +  "    }\n"  +  "\n"  +  "    /** Returns the string concatentation of all nodes following this node up\n"  +  "     * to and excluding the end of the chain or this, which ever is reached\n"  +  "     * first (i.e. this method will terminate even for circular lists).\n"  +  "     */\n"  +  "    protected /*@ pure @*/ String stringOfEntries(\n"  +  "                                     /*@ nullable @*/ OneWayNode curr) \n"  +  "    {\n"  +  "	if (curr == null) {\n"  +  "	    return \"\";\n"  +  "	}\n"  +  "	// Get string representation of entry. (Note the following works even\n"  +  "	// if the entry is null.)\n"  +  "	String entryAsString = curr.getEntry() + \"\";\n"  +  "\n"  +  "	if (!curr.hasNext()\n"  +  "	    // the following disjunct prevents infinite recursion\n"  +  "	    || curr.getNextNode() == this) {\n"  +  "	    return entryAsString;\n"  +  "	}\n"  +  "	return entryAsString + \", \" + stringOfEntries(curr.getNextNode());\n"  +  "    }\n"  +  "    protected OneWayNode(/*@ nullable @*/ Object ent,\n"  +  "                         /*@ nullable @*/ OneWayNode nxtNode)\n"  +  "    {\n"  +  "	entry_ = ent;\n"  +  "	nextNode_ = nxtNode;\n"  +  "    }\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: TwoWayNode.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "class TwoWayNode extends OneWayNode { // Doubly Linked Node\n"  +  "\n"  +  "    // data members\n"  +  "\n"  +  "    protected /*@ nullable @*/ TwoWayNode prevNode_;\n"  +  "\n"  +  "    public TwoWayNode() {\n"  +  "	super();\n"  +  "	prevNode_ = null;\n"  +  "    }\n"  +  "    public TwoWayNode(/*@ nullable @*/ Object ent) {\n"  +  "	super(ent);\n"  +  "	prevNode_ = null;\n"  +  "    }\n"  +  "    public void insertAfter(/*@ nullable @*/ Object newEntry) {\n"  +  "	nextNode_ = new TwoWayNode(newEntry, this, (TwoWayNode)nextNode_);\n"  +  "    }\n"  +  "    public void removeNextNode() {\n"  +  "	if (nextNode_ != null) {\n"  +  "	    TwoWayNode nextNextNode = (TwoWayNode) nextNode_.getNextNode();\n"  +  "\n"  +  "	    // remove the current links\n"  +  "	    // the next line is needed in case nextNode_ is aliased\n"  +  "	    ((TwoWayNode) nextNode_).linkTo(null);\n"  +  "\n"  +  "	    this.linkTo(nextNextNode);\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ pure nullable @*/ TwoWayNode getPrevNode() {\n"  +  "	return prevNode_;\n"  +  "    }\n"  +  "    public void insertBefore(/*@ nullable @*/ Object newEntry) {\n"  +  "	prevNode_ = new TwoWayNode(newEntry, prevNode_, this);\n"  +  "    }\n"  +  "    public String toString() {\n"  +  "	String str = \"\";\n"  +  "	str += stringOfPrevEntries(((TwoWayNode)this).getPrevNode());\n"  +  "	str += \" || \";\n"  +  "	str += stringOfEntries(this);\n"  +  "	return str;\n"  +  "    }\n"  +  "\n"  +  "    /** The first invocation of this method should be with curr ==\n"  +  "     * prevNode_. If this is done, then the string returned will be a\n"  +  "     * concatentation of all nodes prior to this node up to and excluding the\n"  +  "     * end of the chain or this, which ever is reached first (i.e. this method\n"  +  "     * will terminate even for circular lists).\n"  +  "     */\n"  +  "    protected /*@ pure @*/ String stringOfPrevEntries(\n"  +  "                                      /*@ nullable @*/ TwoWayNode curr)\n"  +  "    {\n"  +  "	if (curr == null\n"  +  "	    // the following disjunct prevents infinite recursion\n"  +  "	    || curr == this) {\n"  +  "	    return \"\";\n"  +  "	}\n"  +  "	return stringOfPrevEntries(curr.getPrevNode())\n"  +  "	    + curr.getEntry() + \", \";\n"  +  "    }\n"  +  "    public Object clone() {\n"  +  "	if (nextNode_ == null) {\n"  +  "	    if (prevNode_ == null) {\n"  +  "		return new TwoWayNode(getEntry());\n"  +  "	    } else {\n"  +  "		return new TwoWayNode(getEntry(), \n"  +  "				      prevNode_.clonePrevious(), null);\n"  +  "	    }\n"  +  "	} else {\n"  +  "	    if (prevNode_ == null) {\n"  +  "		return new TwoWayNode(getEntry(), null, \n"  +  "				      ((TwoWayNode)nextNode_).cloneNext());\n"  +  "	    } else {\n"  +  "		return new TwoWayNode(getEntry(), \n"  +  "				      prevNode_.clonePrevious(), \n"  +  "				      ((TwoWayNode)nextNode_).cloneNext());\n"  +  "	    }\n"  +  "	}\n"  +  "    }\n"  +  "    protected /*@ pure @*/ TwoWayNode cloneNext() {\n"  +  "	if (nextNode_ == null) {\n"  +  "	    return new TwoWayNode(getEntry());\n"  +  "	} else {\n"  +  "	    return new TwoWayNode(getEntry(), null, \n"  +  "			      ((TwoWayNode)nextNode_).cloneNext());\n"  +  "	}\n"  +  "    }\n"  +  "    protected /*@ pure @*/ TwoWayNode clonePrevious() {\n"  +  "	if (prevNode_ == null) {\n"  +  "	    return new TwoWayNode(getEntry());\n"  +  "	} else {\n"  +  "	    return new TwoWayNode(getEntry(), prevNode_.clonePrevious(), null);\n"  +  "	}\n"  +  "    }\n"  +  "    private /*@ helper @*/ void linkTo(/*@ nullable @*/ TwoWayNode nxtNode) {\n"  +  "	if (nextNode_ != null) {\n"  +  "	    // needed in case nextNode_ is aliased\n"  +  "\n"  +  "	    ((TwoWayNode)nextNode_).prevNode_ = null;\n"  +  "	}\n"  +  "	if (nxtNode != null) {\n"  +  "	    // has to be done here or in a private helper method \n"  +  "	    // so the invariant holds!\n"  +  "	    nxtNode.prevNode_ = this;\n"  +  "	}\n"  +  "	nextNode_ = nxtNode;\n"  +  "    }\n"  +  "    protected TwoWayNode(/*@ nullable @*/ Object ent,\n"  +  "                         /*@ nullable @*/ TwoWayNode prvNode,\n"  +  "                         /*@ nullable @*/ TwoWayNode nxtNode)\n"  +  "    {\n"  +  "	this(ent);\n"  +  "	if (prvNode != null) {\n"  +  "	    prvNode.linkTo(this);\n"  +  "	}\n"  +  "	if (nxtNode != null) {\n"  +  "	    this.linkTo(nxtNode);\n"  +  "	}\n"  +  "    }\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: OneWayList.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class OneWayList { // Singly Linked List\n"  +  "\n"  +  "    // data members\n"  +  "\n"  +  "    protected OneWayNode theListNode_;\n"  +  "\n"  +  "    // used for inserting and iteration through the List \n"  +  "    protected OneWayNode cursorNode_;\n"  +  "\n"  +  "    public OneWayList() {\n"  +  "	theListNode_ = new OneWayNode(null);\n"  +  "	cursorNode_ = null;\n"  +  "    }\n"  +  "\n"  +  "    // iteration methods\n"  +  "    // -----------------\n"  +  "\n"  +  "    public void firstEntry() {\n"  +  "	// The first node is a sentinel so the first entry is in the 2nd node\n"  +  "	cursorNode_ = theListNode_.getNextNode();\n"  +  "    }\n"  +  "    public void incrementCursor() {\n"  +  "	if (isOffEnd()) {\n"  +  "	    // System.err.println(\"Error in `list2.OneWayList.incrementCursor()': No more List entries\");\n"  +  "	    // System.err.println(\"List is \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `list2.OneWayList.incrementCursor()': No more List entries\\n\"\n"  +  "					    + \"List is \" + this.toString() );\n"  +  "	}\n"  +  "	cursorNode_ = cursorNode_.getNextNode();\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isOffEnd() {\n"  +  "	return cursorNode_ == null;\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isOffFront() {\n"  +  "	return cursorNode_ == theListNode_;\n"  +  "    }\n"  +  "    public /*@ pure @*/ Object getEntry() {\n"  +  "	if (isOffEnd() || isOffFront()) {\n"  +  "	    // The method cannot be pure if it calls the following\n"  +  "	    //System.err.println(\"Error in `list2.OneWayList.getEntry': cursorNode_ is invalid\");\n"  +  "	    //System.err.println(this);\n"  +  "	    throw new IllegalStateException(\"Error in `list2.OneWayList.getEntry': cursorNode_ is invalid\\n\"\n"  +  "					    + \"List is \" + this.toString() );\n"  +  "	}\n"  +  "	return cursorNode_.getEntry();\n"  +  "    }\n"  +  "\n"  +  "    // methods for changing the list\n"  +  "    // -----------------------------\n"  +  "    public void removeEntry() {\n"  +  "	if (isOffEnd() || isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `list2.OneWayList.removeEntry': cursorNode_ is invalid\");\n"  +  "	    // System.err.println(\"List is \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `list2.OneWayList.removeEntry()': cursorNode_ is invalid\\n\"\n"  +  "					    + \"List is \" + this.toString() );\n"  +  "	}\n"  +  "\n"  +  "	// link the previous node to the next node\n"  +  "	cursorNode_ = previousNode(theListNode_, cursorNode_);\n"  +  "	cursorNode_.removeNextNode();\n"  +  "    }\n"  +  "    public void replaceEntry(Object newEntry) {\n"  +  "	cursorNode_.setEntry(newEntry);\n"  +  "    }\n"  +  "    public void insertAfterCursor(Object newEntry) {\n"  +  "	if (isOffEnd()) {\n"  +  "	    // System.err.println(\"Error in `list2.OneWayList.insertAfterCursor': cursorNode_ is invalid\");\n"  +  "	    // System.err.println(\"Attempting to insert \" + newEntry);\n"  +  "	    // System.err.println(\"into list \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `list2.OneWayList.insertAfterCursor()': cursorNode_ is invalid\\n\"\n"  +  "					    + \"Attempting to insert \" + newEntry\n"  +  "					    + \"into list \" + this.toString() );\n"  +  "	}\n"  +  "\n"  +  "	// creat a new Node containing newEntry and insert after cursor\n"  +  "	cursorNode_.insertAfter(newEntry);\n"  +  "    }\n"  +  "    public void insertBeforeCursor(Object newEntry) {\n"  +  "	if (isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `list2.OneWayList.insertBeforeCursor': cursorNode_ is invalid\");\n"  +  "	    // System.err.println(\"Attempting to insert \" + newEntry);\n"  +  "	    // System.err.println(\"into list \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `list2.OneWayList.insertBeforeCursor()': cursorNode_ is invalid\\n\"\n"  +  "					    + \"Attempting to insert \" + newEntry\n"  +  "					    + \"into list \" + this.toString() );\n"  +  "	}\n"  +  "\n"  +  "	cursorNode_ = previousNode(theListNode_, cursorNode_);\n"  +  "\n"  +  "	// link previous Node to new Node\n"  +  "	insertAfterCursor(newEntry);\n"  +  "\n"  +  "	// move the cursor forward to the original Node\n"  +  "	incrementCursor();\n"  +  "	incrementCursor();\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	return new OneWayList(this);\n"  +  "    }\n"  +  "    public /*@ non_null @*/ String toString() {\n"  +  "	String str = \"<\";\n"  +  "	OneWayNode curr = theListNode_.getNextNode();\n"  +  "	while (curr != cursorNode_ && curr != null) {\n"  +  "	    str += curr.getEntry().toString();\n"  +  "	    curr = curr.getNextNode();\n"  +  "	    if (curr.hasNext()) {\n"  +  "		str += \", \";\n"  +  "	    }\n"  +  "	}\n"  +  "	str += \" || \";\n"  +  "	while (curr != null) {\n"  +  "	    str += curr.getEntry().toString();\n"  +  "	    curr = curr.getNextNode();\n"  +  "	    if (curr.hasNext()) {\n"  +  "		str += \", \";\n"  +  "	    }\n"  +  "	}\n"  +  "	str += \">\";\n"  +  "	return str;\n"  +  "    }\n"  +  "\n"  +  "    // ***********************************************************\n"  +  "    // protected methods\n"  +  "\n"  +  "    protected OneWayNode previousNode(OneWayNode curr, OneWayNode node) {\n"  +  "	if (curr.getNextNode() == node) {\n"  +  "	    return curr;\n"  +  "	} else {\n"  +  "	    return previousNode(curr.getNextNode(), node);\n"  +  "	}\n"  +  "    }\n"  +  "    protected OneWayList(OneWayList othLst) {\n"  +  "	theListNode_ = (OneWayNode) othLst.theListNode_.clone();\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "\n"  +  "}\n"  +  "// @(#) $Id: E_OneWayList.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class E_OneWayList extends OneWayList { // Singly Linked List\n"  +  "\n"  +  "    // data members\n"  +  "    protected int length_;\n"  +  "\n"  +  "    public E_OneWayList() {\n"  +  "	super();\n"  +  "	length_ = 0;\n"  +  "    }\n"  +  "\n"  +  "    // accessors\n"  +  "    // ---------\n"  +  "    public /*@ pure @*/ int length() {\n"  +  "	return length_;\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isEmpty() {\n"  +  "	return length_ == 0;\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean equals(/*@ nullable @*/ Object obj) {\n"  +  "	if (! (obj instanceof OneWayList) ) {\n"  +  "	    return false;\n"  +  "	} else {\n"  +  "	    return equalsNode(theListNode_, \n"  +  "		              ((OneWayList)obj).theListNode_);\n"  +  "	}\n"  +  "    }\n"  +  "\n"  +  "    public /*@ pure @*/ int hashCode() {\n"  +  "        if ( isEmpty() ) {\n"  +  "            return super.hashCode();\n"  +  "        } else {\n"  +  "            return theListNode_.getNextNode().getEntry().hashCode() + length();\n"  +  "        }\n"  +  "    }\n"  +  "\n"  +  "    // methods for changing the list\n"  +  "    // -----------------------------\n"  +  "    public void removeEntry() {\n"  +  "	super.removeEntry();\n"  +  "	length_ --;\n"  +  "    }\n"  +  "    public void insertAfterCursor(Object newEntry) {\n"  +  "	super.insertAfterCursor(newEntry);\n"  +  "	length_ ++;\n"  +  "    }\n"  +  "    public void insertBeforeCursor(Object newEntry) {\n"  +  "	cursorNode_ = previousNode(theListNode_, cursorNode_);\n"  +  "	cursorNode_.insertAfter(newEntry);\n"  +  "	incrementCursor();\n"  +  "	incrementCursor();\n"  +  "	length_ ++;\n"  +  "    }\n"  +  "    public void append(Object newEntry) {\n"  +  "	lastEntry();\n"  +  "	if (isOffEnd()) { // empty list is always off the end!\n"  +  "	    insertBeforeCursor(newEntry);\n"  +  "	} else {\n"  +  "	    insertAfterCursor(newEntry);\n"  +  "	    incrementCursor();\n"  +  "	}\n"  +  "    }\n"  +  "    public void removeAllEntries() {\n"  +  "	firstEntry();\n"  +  "	while (!isOffEnd()) {\n"  +  "	    removeEntry();\n"  +  "	    incrementCursor();\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	return new E_OneWayList(this);\n"  +  "    }\n"  +  "\n"  +  "    // ***********************************************************\n"  +  "    // protected methods\n"  +  "\n"  +  "    protected void lastEntry() {\n"  +  "	if (isOffEnd()) {\n"  +  "	    cursorNode_ = theListNode_;\n"  +  "	}\n"  +  "	while (cursorNode_.getNextNode() != null) {\n"  +  "	    incrementCursor();\n"  +  "	}\n"  +  "    }\n"  +  "    protected E_OneWayList(E_OneWayList othLst) {\n"  +  "	super(othLst);\n"  +  "	length_ = othLst.length();\n"  +  "    }\n"  +  "    private /*@ pure @*/ boolean equalsNode(/*@ nullable @*/ OneWayNode nd1, /*@ nullable @*/ OneWayNode nd2) {\n"  +  "	if (nd1 == null && nd2 == null) {\n"  +  "	    return true;\n"  +  "	} else if (nd1 == null || nd2 == null) {\n"  +  "	    return false;\n"  +  "	} else if (nd1.getEntry() == nd2.getEntry()) {\n"  +  "	    if (nd1 == nd2) {\n"  +  "		return false;\n"  +  "	    } else {\n"  +  "		return equalsNode(nd1.getNextNode(), nd2.getNextNode());\n"  +  "	    }\n"  +  "	} else {\n"  +  "	    return false;\n"  +  "	}\n"  +  "    }\n"  +  "}\n"  +  "// @(#) $Id: TwoWayIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class TwoWayIterator implements RestartableIterator {\n"  +  "\n"  +  "    // data members\n"  +  "    protected TwoWayNode firstLink_;\n"  +  "    protected TwoWayNode currLink_;\n"  +  "    protected TwoWayNode lastLink_;\n"  +  "\n"  +  "    public TwoWayIterator(TwoWayNode link) {\n"  +  "	firstLink_ = link;\n"  +  "	currLink_ = firstLink_;\n"  +  "	lastLink_ = firstLink_;\n"  +  "	first();\n"  +  "	while ( !isDone() ) {\n"  +  "	    lastLink_ = currLink_;\n"  +  "	    next();\n"  +  "	}\n"  +  "	first();\n"  +  "	// System.out.println(\"iterator:\" + toString());\n"  +  "    }\n"  +  "    public void first() {\n"  +  "	// first node/link is a sentinel\n"  +  "	currLink_ = (TwoWayNode) firstLink_.getNextNode();\n"  +  "    }\n"  +  "    public void next() {\n"  +  "	currLink_ = (TwoWayNode) currLink_.getNextNode();\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isDone() {\n"  +  "	return currLink_ == null;\n"  +  "    }\n"  +  "    public Object currentItem() {\n"  +  "	return currLink_.getEntry();\n"  +  "    }\n"  +  "    public void last() {\n"  +  "	currLink_ = lastLink_;\n"  +  "    }\n"  +  "    public void previous() {\n"  +  "	if (currLink_ == null) {\n"  +  "	    last();\n"  +  "	} else {\n"  +  "	    currLink_ = currLink_.getPrevNode();\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isAtFront() {\n"  +  "	if (currLink_ == null) {\n"  +  "	    return firstLink_.getNextNode() == null;\n"  +  "	} else {\n"  +  "	    return currLink_.getPrevNode() == firstLink_;\n"  +  "	}\n"  +  "    }\n"  +  "\n"  +  "    // don't allow the default constructor\n"  +  "    protected TwoWayIterator() {\n"  +  "	firstLink_ = new TwoWayNode();\n"  +  "	currLink_ = firstLink_;\n"  +  "	lastLink_ = firstLink_;\n"  +  "	first();\n"  +  "	// System.out.println(\"iterator:\" + toString());\n"  +  "    }\n"  +  "    public /*@ non_null @*/ String toString() {\n"  +  "	OneWayNode curr = firstLink_.getNextNode();\n"  +  "	String str = \"\";\n"  +  "	int index = 0;\n"  +  "	if (currLink_ == firstLink_) {\n"  +  "	    index = -1;\n"  +  "	    str += \" || <\";\n"  +  "	} else {\n"  +  "	    str += \"<\";\n"  +  "	    while (curr != currLink_) {\n"  +  "		str += curr.getEntry();\n"  +  "		if (curr.hasNext()) {\n"  +  "		    str += \", \";\n"  +  "		}\n"  +  "		curr = curr.getNextNode();\n"  +  "		index++;\n"  +  "	    }\n"  +  "	    str += \" || \";\n"  +  "	}\n"  +  "	while (curr != null) {\n"  +  "	    str += curr.getEntry();\n"  +  "	    if (curr.hasNext()) {\n"  +  "		str += \", \";\n"  +  "	    }\n"  +  "	    curr = curr.getNextNode();\n"  +  "	}\n"  +  "	str += \"> currIndex=\" + index;\n"  +  "	return str;\n"  +  "    }\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: TwoWayList.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class TwoWayList extends E_OneWayList { // Doubly Linked List\n"  +  "\n"  +  "    protected TwoWayNode lastNode_;\n"  +  "\n"  +  "    public TwoWayList() {\n"  +  "	theListNode_ = new TwoWayNode(null);\n"  +  "	length_ = 0;\n"  +  "\n"  +  "	// The next statements are needed to satisfy the class invariant!!!\n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "	cursorNode_ = theListNode_;\n"  +  "	lastNode_ = (TwoWayNode) theListNode_;\n"  +  "\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "    // iteration methods\n"  +  "    // -----------------\n"  +  "\n"  +  "    // NEW iteration methods (for doubly linked list)\n"  +  "    // ---------------------\n"  +  "    public void decrementCursor() {\n"  +  "	if (isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `list2.TwoWayList.decrementCursor': cursorNode_ is invalid\");\n"  +  "	    throw new IllegalStateException(\"Error in `list2.TwoWayList.decrementCursor': cursorNode_ is invalid\");\n"  +  "	}\n"  +  "	if (isOffEnd()) {\n"  +  "	    lastEntry();\n"  +  "	} else {\n"  +  "	    cursorNode_ = ((TwoWayNode)cursorNode_).getPrevNode();\n"  +  "	}\n"  +  "    }\n"  +  "    public void lastEntry() {\n"  +  "	cursorNode_ = lastNode_;\n"  +  "    }\n"  +  "    public void removeEntry() {\n"  +  "	if (isOffEnd() || isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `list2.TwoWayList.removeEntry': cursorNode_ is invalid\\n\"\n"  +  "	    //	       + \"List is \" + this.toString() );\n"  +  "	    throw new IllegalStateException(\"Error in `list2.TwoWayList.removeEntry': cursorNode_ is invalid\\n\"\n"  +  "					    + \"List is \" + this.toString() );\n"  +  "	}\n"  +  "\n"  +  "	decrementCursor();\n"  +  "\n"  +  "	if (cursorNode_.getNextNode() == lastNode_) {\n"  +  "	    lastNode_ = (TwoWayNode) cursorNode_;\n"  +  "	}\n"  +  "\n"  +  "	cursorNode_.removeNextNode();\n"  +  "	length_ --;\n"  +  "    }\n"  +  "    public void insertAfterCursor(Object newEntry) {\n"  +  "	if ( isOffEnd() ) {\n"  +  "	    decrementCursor();\n"  +  "	    cursorNode_.insertAfter(newEntry);\n"  +  "	    incrementCursor();\n"  +  "	    lastNode_ = (TwoWayNode) cursorNode_;\n"  +  "	    incrementCursor();\n"  +  "	    length_ ++;\n"  +  "	} else {\n"  +  "	    super.insertAfterCursor(newEntry);\n"  +  "	    // cursorNode_.insertAfter(newEntry);\n"  +  "	    // length_ ++;\n"  +  "	    if (lastNode_ == cursorNode_) {\n"  +  "		lastNode_ = (TwoWayNode) cursorNode_.getNextNode();\n"  +  "	    }\n"  +  "	}\n"  +  "    }\n"  +  "    public void insertBeforeCursor(Object newEntry) {\n"  +  "	if ( isOffFront() || isOffEnd() ) {\n"  +  "	    insertAfterCursor(newEntry);\n"  +  "	} else {\n"  +  "	    decrementCursor();\n"  +  "	    insertAfterCursor(newEntry);\n"  +  "	    incrementCursor();\n"  +  "	    incrementCursor();\n"  +  "	    // ((TwoWayNode)cursorNode_).insertBefore(newEntry);\n"  +  "	    // length_ ++;\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	return(new TwoWayList(this));\n"  +  "    }\n"  +  "    public TwoWayIterator createIterator() {\n"  +  "	// System.out.println(\"creating:\" + toString());\n"  +  "	return new TwoWayIterator( (TwoWayNode) theListNode_ );\n"  +  "    }\n"  +  "\n"  +  "    // ***********************************************************\n"  +  "    // protected methods\n"  +  "\n"  +  "    protected TwoWayList(TwoWayList othLst) {\n"  +  "	theListNode_ = (TwoWayNode) othLst.theListNode_.clone();\n"  +  "	length_ = othLst.length_;\n"  +  "	cursorNode_ = theListNode_;\n"  +  "\n"  +  "	// set the lastNode_ field\n"  +  "	lastNode_ = (TwoWayNode) theListNode_;\n"  +  "	while (lastNode_.getNextNode() != null) {\n"  +  "	    lastNode_ = (TwoWayNode) lastNode_.getNextNode();\n"  +  "	}\n"  +  "\n"  +  "	// To satisfy the class invariant the \n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "\n"  +  "}\n"  )  ; 

