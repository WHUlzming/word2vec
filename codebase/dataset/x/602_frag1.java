    static short[] black = { 62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 3225, 588, 588, 588, 588, 588, 588, 588, 588, 1680, 1680, 20499, 22547, 24595, 26643, 1776, 1776, 1808, 1808, -24557, -22509, -20461, -18413, 1904, 1904, 1936, 1936, -16365, -14317, 782, 782, 782, 782, 814, 814, 814, 814, -12269, -10221, 10257, 10257, 12305, 12305, 14353, 14353, 16403, 18451, 1712, 1712, 1744, 1744, 28691, 30739, -32749, -30701, -28653, -26605, 2061, 2061, 2061, 2061, 2061, 2061, 2061, 2061, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 424, 750, 750, 750, 750, 1616, 1616, 1648, 1648, 1424, 1424, 1456, 1456, 1488, 1488, 1520, 1520, 1840, 1840, 1872, 1872, 1968, 1968, 8209, 8209, 524, 524, 524, 524, 524, 524, 524, 524, 556, 556, 556, 556, 556, 556, 556, 556, 1552, 1552, 1584, 1584, 2000, 2000, 2032, 2032, 976, 976, 1008, 1008, 1040, 1040, 1072, 1072, 1296, 1296, 1328, 1328, 718, 718, 718, 718, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 456, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 326, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 358, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 490, 4113, 4113, 6161, 6161, 848, 848, 880, 880, 912, 912, 944, 944, 622, 622, 622, 622, 654, 654, 654, 654, 1104, 1104, 1136, 1136, 1168, 1168, 1200, 1200, 1232, 1232, 1264, 1264, 686, 686, 686, 686, 1360, 1360, 1392, 1392, 12, 12, 12, 12, 12, 12, 12, 12, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390, 390 };



    static byte[] twoDCodes = { 80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4, 4, 4, 4, 4, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 35, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41, 41 };



    /**

	 * @param fillOrder

	 *            The fill order of the compressed data bytes.

	 * @param w

	 * @param h

	 */

    public TIFFFaxDecoder(int fillOrder, int w, int h) {

        this.fillOrder = fillOrder;

        this.w = w;

        this.bitPointer = 0;

        this.bytePointer = 0;

        this.prevChangingElems = new int[w];

        this.currChangingElems = new int[w];

    }



    public void decode1D(byte[] buffer, byte[] compData, int startX, int height) {

        this.data = compData;

        int lineOffset = 0;

        int scanlineStride = (w + 7) / 8;

        bitPointer = 0;

        bytePointer = 0;

        for (int i = 0; i < height; i++) {

            decodeNextScanline(buffer, lineOffset, startX);

            lineOffset += scanlineStride;

        }

    }



    protected void decodeNextScanline(byte[] buffer, int lineOffset, int bitOffset) {

        int bits = 0;

        int code = 0;

        int isT = 0;

        int current;

        int entry;

        int twoBits;

        boolean isWhite = true;

        changingElemSize = 0;

        while (bitOffset < w) {

            while (isWhite) {

                current = nextNBits(10);

                entry = white[current];

                isT = entry & 0x0001;

                bits = (entry >>> 1) & 0x0f;

                if (bits == 12) {

                    twoBits = nextLesserThan8Bits(2);

                    current = ((current << 2) & 0x000c) | twoBits;

                    entry = additionalMakeup[current];

                    bits = (entry >>> 1) & 0x07;

                    code = (entry >>> 4) & 0x0fff;

                    bitOffset += code;

                    updatePointer(4 - bits);

                } else if (bits == 0) {

                    throw new RuntimeException("Invalid code encountered.");

                } else if (bits == 15) {

                    throw new RuntimeException("EOL code word encountered in White run.");

                } else {

                    code = (entry >>> 5) & 0x07ff;

                    bitOffset += code;

                    updatePointer(10 - bits);

                    if (isT == 0) {

                        isWhite = false;

                        currChangingElems[changingElemSize++] = bitOffset;

                    }

                }

            }

            if (bitOffset == w) {

                if (compression == 2) {

                    advancePointer();

                }

                break;

            }

            while (isWhite == false) {

                current = nextLesserThan8Bits(4);

                entry = initBlack[current];

                isT = entry & 0x0001;

                bits = (entry >>> 1) & 0x000f;

                code = (entry >>> 5) & 0x07ff;

                if (code == 100) {

                    current = nextNBits(9);

                    entry = black[current];

                    isT = entry & 0x0001;

                    bits = (entry >>> 1) & 0x000f;

                    code = (entry >>> 5) & 0x07ff;

                    if (bits == 12) {

                        updatePointer(5);

                        current = nextLesserThan8Bits(4);

                        entry = additionalMakeup[current];

                        bits = (entry >>> 1) & 0x07;

                        code = (entry >>> 4) & 0x0fff;

                        setToBlack(buffer, lineOffset, bitOffset, code);

                        bitOffset += code;

                        updatePointer(4 - bits);

                    } else if (bits == 15) {

                        throw new RuntimeException("EOL code word encountered in Black run.");

                    } else {

                        setToBlack(buffer, lineOffset, bitOffset, code);

                        bitOffset += code;

                        updatePointer(9 - bits);

                        if (isT == 0) {

                            isWhite = true;

                            currChangingElems[changingElemSize++] = bitOffset;

                        }

                    }

                } else if (code == 200) {

                    current = nextLesserThan8Bits(2);

                    entry = twoBitBlack[current];

                    code = (entry >>> 5) & 0x07ff;

                    bits = (entry >>> 1) & 0x0f;

                    setToBlack(buffer, lineOffset, bitOffset, code);

                    bitOffset += code;

                    updatePointer(2 - bits);

                    isWhite = true;

                    currChangingElems[changingElemSize++] = bitOffset;

                } else {

                    setToBlack(buffer, lineOffset, bitOffset, code);

                    bitOffset += code;

                    updatePointer(4 - bits);

                    isWhite = true;

                    currChangingElems[changingElemSize++] = bitOffset;

                }

            }

            if (bitOffset == w) {

                if (compression == 2) {

                    advancePointer();

                }

                break;

            }

        }

        currChangingElems[changingElemSize++] = bitOffset;

    }



    public void decode2D(byte[] buffer, byte[] compData, int startX, int height, long tiffT4Options) {

        this.data = compData;

        compression = 3;

        bitPointer = 0;

        bytePointer = 0;

        int scanlineStride = (w + 7) / 8;

        int a0;

        int a1;

        int b1;

        int b2;

        int[] b = new int[2];

        int entry;

        int code;

        int bits;

        boolean isWhite;

        int currIndex = 0;

        int[] temp;

        oneD = (int) (tiffT4Options & 0x01);

        fillBits = (int) ((tiffT4Options & 0x04) >> 2);

        if (readEOL(true) != 1) {

            throw new RuntimeException("First scanline must be 1D encoded.");

        }

        int lineOffset = 0;

        int bitOffset;

        decodeNextScanline(buffer, lineOffset, startX);

        lineOffset += scanlineStride;

        for (int lines = 1; lines < height; lines++) {

            if (readEOL(false) == 0) {

                temp = prevChangingElems;

                prevChangingElems = currChangingElems;

                currChangingElems = temp;

                currIndex = 0;

                a0 = -1;

                isWhite = true;

                bitOffset = startX;

                lastChangingElement = 0;

                while (bitOffset < w) {

                    getNextChangingElement(a0, isWhite, b);

                    b1 = b[0];

                    b2 = b[1];

                    entry = nextLesserThan8Bits(7);

                    entry = (int) (twoDCodes[entry] & 0xff);

                    code = (entry & 0x78) >>> 3;

                    bits = entry & 0x07;

                    if (code == 0) {
