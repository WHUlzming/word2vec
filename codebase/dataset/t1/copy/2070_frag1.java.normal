compile  (  "DLList.java"  ,  "// @(#) $Id: SLNode.java 1199 2009-02-17 1f9:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class SLNode { // Singly Linked Node\n"  +  "\n"  +  "    // data members\n"  +  "\n"  +  "    protected Object entry_;\n"  +  "    protected SLNode nextNode_;\n"  +  "\n"  +  "    // methods\n"  +  "\n"  +  "    public SLNode(Object ent) {\n"  +  "	entry_ = ent;\n"  +  "	nextNode_ = null;\n"  +  "    }\n"  +  "    public /*@ pure @*/ Object getEntry() {\n"  +  "	return entry_;\n"  +  "    }\n"  +  "    public void setEntry(Object newEntry) {\n"  +  "	entry_ = newEntry;\n"  +  "    }\n"  +  "    public /*@ pure @*/ SLNode getNextNode() {\n"  +  "	return nextNode_;\n"  +  "    }\n"  +  "    public void insertAfter(Object newEntry) {\n"  +  "	nextNode_ = new SLNode(newEntry, nextNode_);\n"  +  "    }\n"  +  "    public void removeNextNode() {\n"  +  "	if (nextNode_ != null) {\n"  +  "	    nextNode_ = nextNode_.getNextNode();\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	if (nextNode_ == null) {\n"  +  "	    return new SLNode(getEntry());\n"  +  "	} else {\n"  +  "	    return new SLNode(getEntry(), (SLNode)nextNode_.clone());\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ pure non_null @*/ String toString() {\n"  +  "	return getEntry() + \", \" + stringOfEntries(getNextNode());\n"  +  "    }\n"  +  "\n"  +  "    /** Returns the string concatentation of all nodes following this node up\n"  +  "     * to and excluding the end of the chain or this, which ever is reached\n"  +  "     * first (i.e. this method will terminate even for circular lists).\n"  +  "     */\n"  +  "    protected /*@ pure @*/ String stringOfEntries(SLNode curr) {\n"  +  "	if (curr == null) {\n"  +  "	    return \"\";\n"  +  "	}\n"  +  "	// Get string representation of entry. (Note the following works even\n"  +  "	// if the entry is null.)\n"  +  "	String entryAsString = curr.getEntry() + \"\";\n"  +  "\n"  +  "	if (curr.getNextNode() == null\n"  +  "	    // the following disjunct prevents infinite recursion\n"  +  "	    || curr.getNextNode() == this) {\n"  +  "	    return entryAsString;\n"  +  "	}\n"  +  "	return entryAsString + \", \" + stringOfEntries(curr.getNextNode());\n"  +  "    }\n"  +  "    protected SLNode() {\n"  +  "	entry_ = null;\n"  +  "	nextNode_ = null;\n"  +  "    }\n"  +  "    protected SLNode(Object ent, SLNode nxtNode) {\n"  +  "	entry_ = ent;\n"  +  "	nextNode_ = nxtNode;\n"  +  "    }\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: DLNode.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class DLNode extends SLNode { // Doubly Linked Node\n"  +  "\n"  +  "    // data members\n"  +  "\n"  +  "    protected DLNode prevNode_;\n"  +  "\n"  +  "    public DLNode(Object ent) {\n"  +  "	super(ent);\n"  +  "	prevNode_ = null;\n"  +  "    }\n"  +  "\n"  +  "    public void insertAfter(Object newEntry) {\n"  +  "	nextNode_ = new DLNode(newEntry, this, (DLNode)nextNode_);\n"  +  "    }\n"  +  "    public void removeNextNode() {\n"  +  "	if (nextNode_ != null) {\n"  +  "	    DLNode nextNext = (DLNode) nextNode_.getNextNode();\n"  +  "\n"  +  "	    // remove the current links\n"  +  "	    // the next two lines are needed in case nextNode_ is aliased\n"  +  "	    ((DLNode)nextNode_).linkTo(null);\n"  +  "\n"  +  "	    this.linkTo(nextNext);\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ pure @*/ DLNode getPrevNode() {\n"  +  "	return prevNode_;\n"  +  "    }\n"  +  "    public void insertBefore(Object newEntry) {\n"  +  "	if (prevNode_ != null) {\n"  +  "	    prevNode_.insertAfter(newEntry);\n"  +  "	} else {\n"  +  "	    prevNode_ = new DLNode(newEntry, null, this);\n"  +  "	}\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	if (nextNode_ == null) {\n"  +  "	    if (prevNode_ == null) {\n"  +  "		return new DLNode(getEntry());\n"  +  "	    } else {\n"  +  "		return new DLNode(getEntry(), prevNode_.clonePrevious(), null);\n"  +  "	    }\n"  +  "	} else {\n"  +  "	    if (prevNode_ == null) {\n"  +  "		return new DLNode(getEntry(), null, \n"  +  "				  ((DLNode)nextNode_).cloneNext());\n"  +  "	    } else {\n"  +  "		return new DLNode(getEntry(), \n"  +  "				  prevNode_.clonePrevious(), \n"  +  "				  ((DLNode)nextNode_).cloneNext());\n"  +  "	    }\n"  +  "	}\n"  +  "    }\n"  +  "    protected DLNode cloneNext() {\n"  +  "	if (nextNode_ == null) {\n"  +  "	    return new DLNode(getEntry());\n"  +  "	} else {\n"  +  "	    return new DLNode(getEntry(), null, \n"  +  "			      ((DLNode)nextNode_).cloneNext());\n"  +  "	}\n"  +  "    }\n"  +  "    protected DLNode clonePrevious() {\n"  +  "	if (prevNode_ == null) {\n"  +  "	    return new DLNode(getEntry());\n"  +  "	} else {\n"  +  "	    return new DLNode(getEntry(), prevNode_.clonePrevious(), null);\n"  +  "	}\n"  +  "    }\n"  +  "    protected void linkTo(DLNode nxtNode) {\n"  +  "	if (nextNode_ != null) { // needed in case nextNode_ is aliased\n"  +  "	    ((DLNode)nextNode_).prevNode_ = null;\n"  +  "	}\n"  +  "	if (nxtNode != null) {\n"  +  "	    nxtNode.prevNode_ = this;\n"  +  "	}\n"  +  "	this.nextNode_ = nxtNode;\n"  +  "    }\n"  +  "    protected DLNode(Object ent, DLNode prvNode, DLNode nxtNode) {\n"  +  "	this(ent);\n"  +  "	if (prvNode != null) {\n"  +  "	    prvNode.linkTo(this);\n"  +  "	}\n"  +  "	if (nxtNode != null) {\n"  +  "	    this.linkTo(nxtNode);\n"  +  "	}\n"  +  "    }\n"  +  "}\n"  +  "// @(#) $Id: SLList.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class SLList { // Singly Linked List\n"  +  "\n"  +  "    // data members\n"  +  "\n"  +  "    protected /*@non_null*/ SLNode theListNode_;\n"  +  "\n"  +  "    // used for inserting and iteration through the List \n"  +  "    protected SLNode cursorNode_;\n"  +  "\n"  +  "    public SLList() {\n"  +  "	theListNode_ = new SLNode(null);\n"  +  "	cursorNode_ = null;\n"  +  "    }\n"  +  "\n"  +  "    // iteration methods\n"  +  "    // -----------------\n"  +  "\n"  +  "    public void firstEntry() {\n"  +  "	// The first node is a sentinel so the first entry is in the 2nd node\n"  +  "	cursorNode_ = theListNode_.getNextNode();\n"  +  "    }\n"  +  "    public void incrementCursor() {\n"  +  "	if (isOffEnd()) {\n"  +  "	    // System.err.println(\"Error in `SLList.incrementCursor()': No more List entries\"\n"  +  "	    //	       + \"List is \" + this.toString() );\n"  +  "	    throw new IllegalStateException(\"Error in `SLList.OneWayList.incrementCursor()': No more List entries\\n\"\n"  +  "					    + \"List is \" + this.toString() );\n"  +  "	}\n"  +  "	cursorNode_ = cursorNode_.getNextNode();\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isOffFront() {\n"  +  "	return cursorNode_ == theListNode_;\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isOffEnd() {\n"  +  "	return cursorNode_ == null;\n"  +  "    }\n"  +  "    public /*@ pure @*/ Object getEntry() {\n"  +  "	if (isOffEnd() || isOffFront()) {\n"  +  "	    // The following line is not pure\n"  +  "	    //System.err.println(\"Error in `SLList.getEntry': cursorNode_ is invalid\");\n"  +  "	    throw new IllegalStateException(\"Error in `SLList.getEntry': cursorNode_ is invalid\");\n"  +  "	}\n"  +  "	return cursorNode_.getEntry();\n"  +  "    }\n"  +  "\n"  +  "    // methods for changing the list\n"  +  "    // -----------------------------\n"  +  "    public void removeEntry() {\n"  +  "	if (isOffEnd() || isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `SLList.removeEntry': cursorNode_ is invalid\");\n"  +  "	    // System.err.println(\"List is \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `SLList.removeEntry':\"\n"  +  "					    + \"cursorNode_ is invalid\\n\"\n"  +  "					    + \"List is \" + this.toString());\n"  +  "	}\n"  +  "\n"  +  "	// link the previous node to the next node\n"  +  "	decreaseCursor();\n"  +  "	cursorNode_.removeNextNode();\n"  +  "    }\n"  +  "    public void replaceEntry(Object newEntry) {\n"  +  "	cursorNode_.setEntry(newEntry);\n"  +  "    }\n"  +  "    public void insertAfterCursor(Object newEntry) {\n"  +  "	if (isOffEnd()) {\n"  +  "	    // System.err.println(\"Error in `SLList.insertAfterCursor': cursorNode_ is invalid\");\n"  +  "	    // System.err.println(\"Attempting to insert \" + newEntry);\n"  +  "	    // System.err.println(\"into list \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `SLList.insertAfterCursor':\"\n"  +  "					    + \" cursorNode_ is invalid\\n\"\n"  +  "					    + \"Attempting to insert \" \n"  +  "					    + newEntry \n"  +  "					    + \"into list \" + this.toString() );\n"  +  "	}\n"  +  "\n"  +  "	// creat a new Node containing newEntry and insert after cursor\n"  +  "	cursorNode_.insertAfter(newEntry);\n"  +  "    }\n"  +  "    public void insertBeforeCursor(Object newEntry) {\n"  +  "	if (isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `SLList.insertBeforeCursor': cursorNode_ is invalid\");\n"  +  "	    // System.err.println(\"Attempting to insert \" + newEntry);\n"  +  "	    // System.err.println(\"into list \" + this.toString());\n"  +  "	    throw new IllegalStateException(\"Error in `SLList.insertBeforeCursor':\"\n"  +  "					    + \" cursorNode_ is invalid\\n\"\n"  +  "					    + \"Attempting to insert \" \n"  +  "					    + newEntry \n"  +  "					    + \"into list \" + this.toString() );\n"  +  "	}\n"  +  "\n"  +  "	decreaseCursor();\n"  +  "\n"  +  "	// link previous Node to new Node\n"  +  "	insertAfterCursor(newEntry);\n"  +  "\n"  +  "	// move the cursor forward to the original Node\n"  +  "	incrementCursor();\n"  +  "	incrementCursor();\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	SLList result = new SLList( theListNode_ );\n"  +  "	return result;\n"  +  "    }\n"  +  "    public /*@ non_null @*/ String toString() {\n"  +  "	String str = \"<\";\n"  +  "	SLNode curr = theListNode_.getNextNode();\n"  +  "	while (curr != cursorNode_ && curr != null) {\n"  +  "	    str = str + curr.getEntry();\n"  +  "	    curr = curr.getNextNode();\n"  +  "	    if (curr != null && curr.getNextNode() != null) {\n"  +  "		str += \", \";\n"  +  "	    }\n"  +  "	}\n"  +  "	str += \" || \";\n"  +  "	while (curr != null) {\n"  +  "	    str = str + curr.getEntry();\n"  +  "	    curr = curr.getNextNode();\n"  +  "	    if (curr != null && curr.getNextNode() != null) {\n"  +  "		str += \", \";\n"  +  "	    }\n"  +  "	}\n"  +  "	str += \">\";\n"  +  "	return str;\n"  +  "    }\n"  +  "\n"  +  "    // ***********************************************************\n"  +  "    // protected methods\n"  +  "\n"  +  "    protected void decreaseCursor() {\n"  +  "	if (isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `SLList.decreaseCursor': cursorNode_ is invalid\");\n"  +  "	    throw new IllegalStateException(\"Error in `SLList.decreaseCursor': cursorNode_ is invalid\");\n"  +  "	}\n"  +  "	SLNode origCursor = cursorNode_;\n"  +  "\n"  +  "	firstEntry();\n"  +  "\n"  +  "	if (cursorNode_ == origCursor) {\n"  +  "	    cursorNode_ = theListNode_;\n"  +  "	} else {\n"  +  "	    while (!isOffEnd() && cursorNode_.getNextNode() != origCursor) {\n"  +  "		incrementCursor();\n"  +  "	    }\n"  +  "	}\n"  +  "    }\n"  +  "    protected SLList(SLList othLst) {\n"  +  "	theListNode_ = (SLNode)othLst.theListNode_.clone();\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "    protected SLList(SLNode listNode) {\n"  +  "	theListNode_ = (SLNode)listNode.clone();\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "\n"  +  "}\n"  +  "// @(#) $Id: E_SLList.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class E_SLList extends SLList { // Singly Linked List\n"  +  "\n"  +  "    // data members\n"  +  "    protected int length_;\n"  +  "    protected int log_;\n"  +  "\n"  +  "    public E_SLList() {\n"  +  "	super();\n"  +  "	length_ = 0;\n"  +  "	log_ = 0;\n"  +  "    }\n"  +  "    // accessors\n"  +  "    // ---------\n"  +  "    public /*@ pure @*/ int length() {\n"  +  "	return length_;\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isEmpty() {\n"  +  "	return length_ == 0;\n"  +  "    }\n"  +  "\n"  +  "    // to allow multiple iterations over the same list\n"  +  "    // -----------------------------------------------\n"  +  "    public ListIterator createIterator() {\n"  +  "	return(new ListIterator(this));\n"  +  "    }\n"  +  "\n"  +  "    // methods for changing the list\n"  +  "    // -----------------------------\n"  +  "    public void removeEntry() {\n"  +  "	super.removeEntry();\n"  +  "	length_ --;\n"  +  "	log_++;\n"  +  "    }\n"  +  "    public void insertAfterCursor(Object newEntry) {\n"  +  "	super.insertAfterCursor(newEntry);\n"  +  "	length_ ++;\n"  +  "	log_++;\n"  +  "    }\n"  +  "    public void insertBeforeCursor(Object newEntry) {\n"  +  "\n"  +  "	decreaseCursor();\n"  +  "\n"  +  "	// link previous Node to new Node\n"  +  "	insertAfterCursor(newEntry);\n"  +  "\n"  +  "	// move the cursor forward to the original Node\n"  +  "	incrementCursor();\n"  +  "	incrementCursor();\n"  +  "	log_++;\n"  +  "    }\n"  +  "\n"  +  "    public void replaceEntry(Object newEntry) {\n"  +  "	super.replaceEntry(newEntry);\n"  +  "	log_++;\n"  +  "    }\n"  +  "    public void append(Object newEntry) {\n"  +  "	lastEntry();\n"  +  "	insertAfterCursor(newEntry);\n"  +  "	incrementCursor();\n"  +  "	log_++;\n"  +  "    }\n"  +  "    public void removeAllEntries() {\n"  +  "	firstEntry();\n"  +  "	while (!isOffEnd()) {\n"  +  "	    removeEntry();\n"  +  "	    incrementCursor();\n"  +  "	}\n"  +  "	log_++;\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	E_SLList result = new E_SLList( theListNode_, length_ );\n"  +  "	return result;\n"  +  "    }\n"  +  "\n"  +  "    // ***********************************************************\n"  +  "    // protected methods\n"  +  "\n"  +  "    protected void lastEntry() {\n"  +  "	if (isOffEnd()) {\n"  +  "	    decreaseCursor();\n"  +  "	} else {\n"  +  "\n"  +  "	    SLNode lastNode = cursorNode_;\n"  +  "\n"  +  "	    while (!isOffEnd()) {\n"  +  "		lastNode = cursorNode_;\n"  +  "		incrementCursor();\n"  +  "	    }\n"  +  "	    cursorNode_ = lastNode;\n"  +  "	}\n"  +  "    }\n"  +  "\n"  +  "    protected E_SLList(E_SLList othLst) {\n"  +  "	super(othLst);\n"  +  "	length_ = othLst.length_;\n"  +  "	log_ = othLst.log_;\n"  +  "	// To satisfy the class invariant the \n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "    protected E_SLList(SLNode listNode, int len) {\n"  +  "	//	super(listNode);\n"  +  "	theListNode_ = (SLNode)listNode.clone();\n"  +  "	length_ = len;\n"  +  "	log_ = 0;\n"  +  "	// To satisfy the class invariant the \n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "}\n"  +  "// @(#) $Id: Iterator.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author: Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "interface Iterator { \n"  +  "\n"  +  "  //@ public model instance Object uniteratedElems;\n"  +  "  //@ public model instance nullable Object currElem;\n"  +  "  //@ public model instance boolean unchanged;\n"  +  "\n"  +  "  /*@ public instance invariant currElem == null;\n"  +  "    @*/\n"  +  "\n"  +  "  /*@  public normal_behavior\n"  +  "    @    requires unchanged && !isDone();\n"  +  "    @*/\n"  +  "  public void next();\n"  +  "\n"  +  "  /*@  public normal_behavior\n"  +  "    @    requires unchanged;\n"  +  "    @    assignable \\nothing;\n"  +  "    @*/\n"  +  "  public /*@ pure @*/ boolean isDone();\n"  +  "\n"  +  "  /*@  public normal_behavior\n"  +  "    @    requires unchanged && !isDone();\n"  +  "    @    assignable \\nothing;\n"  +  "    @    ensures \\result == currElem;\n"  +  "    @*/\n"  +  "  public /*@ pure nullable @*/ Object currentItem();\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: RestartableIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author: Clyde Ruby\n"  +  "\n"  +  "interface RestartableIterator extends Iterator {\n"  +  "\n"  +  "    /*@ public model instance Object iteratedElems;\n"  +  "      @*/\n"  +  "\n"  +  "  /*@\n"  +  "    @  public normal_behavior\n"  +  "    @    requires unchanged;\n"  +  "    @    assignable iteratedElems, currElem, uniteratedElems;\n"  +  "  public void first();\n"  +  "\n"  +  "  /*@\n"  +  "    @ also\n"  +  "    @  public normal_behavior\n"  +  "    @    requires unchanged && !isDone();\n"  +  "    @    assignable iteratedElems;\n"  +  "    @*/\n"  +  "  public void next();\n"  +  "\n"  +  "  /*@\n"  +  "    @ also\n"  +  "    @  public normal_behavior\n"  +  "    @    requires unchanged;\n"  +  "    @    assignable \\nothing;\n"  +  "    @*/\n"  +  "  public /*@ pure @*/ boolean isDone();\n"  +  "\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: ListIterator.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "class ListIterator implements RestartableIterator {\n"  +  "\n"  +  "    // data members\n"  +  "    protected E_SLList listRef_;\n"  +  "\n"  +  "    protected int origLog_;\n"  +  "\n"  +  "    //@ protected represents listPtr <- listRef_;\n"  +  "    //@ protected represents currIndex <- listRef_.cursor;\n"  +  "    //@ protected represents origChgLog <- origLog_;\n"  +  "\n"  +  "    /*@ protected represents currElem <- \n"  +  "      @     (!listRef_.isOffFront() && !listRef_.isOffEnd())\n"  +  "      @   ? currentItem()\n"  +  "      @   : null;\n"  +  "      @*/\n"  +  "\n"  +  "    //@ protected represents currIndex <- listRef_.cursor;\n"  +  "    //@ protected represents unchanged <- (listRef_.changeLog == origChgLog);\n"  +  "\n"  +  "  /*@ also\n"  +  "    @ protected normal_behavior\n"  +  "    @   requires lst != null;\n"  +  "    @   assignable listRef_, listRef_.cursor, origLog_;\n"  +  "    @   ensures listRef_.cursor == 0\n"  +  "    @         && listRef_.theList.equals(lst.theList)\n"  +  "    @         && \\fresh(listRef_);\n"  +  "    @*/\n"  +  "    public ListIterator(E_SLList lst) {\n"  +  "	origLog_ = lst.log_;\n"  +  "	listRef_ = (E_SLList)lst.clone();\n"  +  "	listRef_.firstEntry();\n"  +  "    }\n"  +  "\n"  +  "    // don't allow the default constructor\n"  +  "    private ListIterator() {\n"  +  "    }\n"  +  "\n"  +  "  /*@ also\n"  +  "    @ protected normal_behavior\n"  +  "    @   assignable listRef_.cursor;\n"  +  "    @   ensures listRef_.cursor == 0;\n"  +  "    @*/\n"  +  "    public void first() {\n"  +  "	listRef_.firstEntry();\n"  +  "    }\n"  +  "\n"  +  "  /*@ also\n"  +  "    @ protected normal_behavior\n"  +  "    @   requires !listRef_.isOffEnd();\n"  +  "    @   assignable listRef_.cursor;\n"  +  "    @   ensures listRef_.cursor == \\pre(listRef_.cursor + 1);\n"  +  "    @*/\n"  +  "    public void next() {\n"  +  "	listRef_.incrementCursor();\n"  +  "    }\n"  +  "\n"  +  "  /*@ also\n"  +  "    @ protected normal_behavior \n"  +  "    @   assignable \\nothing;\n"  +  "    @   ensures \\result \n"  +  "    @       == (listRef_.cursor == listRef_.theList.int_length());\n"  +  "    @*/\n"  +  "    public boolean isDone() {\n"  +  "	return(listRef_.isOffEnd());\n"  +  "    }\n"  +  "\n"  +  "  /*@ also\n"  +  "    @ protected normal_behavior \n"  +  "    @   requires !listRef_.isOffFront() && !listRef_.isOffEnd();\n"  +  "    @   requires_redundantly listRef_.length() > 0;\n"  +  "    @   assignable \\nothing;\n"  +  "    @   ensures \\result == listRef_.theList.itemAt(listRef_.cursor);\n"  +  "    @*/\n"  +  "    public Object currentItem() {\n"  +  "	return(listRef_.getEntry());\n"  +  "    }\n"  +  "    public /*@ non_null @*/ String toString() {\n"  +  "	return listRef_.toString();\n"  +  "    }\n"  +  "\n"  +  "}\n"  +  "\n"  +  "// @(#) $Id: DLList.java 1199 2009-02-17 19:42:32Z smshaner $\n"  +  "\n"  +  "// Copyright (C) 1998, 1999 Iowa State University\n"  +  "\n"  +  "// This file is part of JML\n"  +  "\n"  +  "// JML is free software; you can redistribute it and/or modify\n"  +  "// it under the terms of the GNU General Public License as published by\n"  +  "// the Free Software Foundation; either version 2, or (at your option)\n"  +  "// any later version.\n"  +  "\n"  +  "// JML is distributed in the hope that it will be useful,\n"  +  "// but WITHOUT ANY WARRANTY; without even the implied warranty of\n"  +  "// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"  +  "// GNU General Public License for more details.\n"  +  "\n"  +  "// You should have received a copy of the GNU General Public License\n"  +  "// along with JML; see the file COPYING.  If not, write to\n"  +  "// the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n"  +  "\n"  +  "// Author:  Clyde Ruby\n"  +  "\n"  +  "\n"  +  "// FIXME: adapt this file to non-null-by-default and remove the following modifier.\n"  +  "/*@ nullable_by_default @*/ \n"  +  "public class DLList extends E_SLList { // Doubly Linked List\n"  +  "\n"  +  "    protected DLNode lastNode_;\n"  +  "\n"  +  "    public DLList() {\n"  +  "	theListNode_ = new DLNode(null);\n"  +  "	length_ = 0;\n"  +  "\n"  +  "	// To satisfy the class invariant the \n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "	cursorNode_ = theListNode_;\n"  +  "	theListNode_.insertAfter(null);\n"  +  "	lastNode_ = (DLNode) theListNode_.getNextNode();\n"  +  "\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "    // iteration methods\n"  +  "    // -----------------\n"  +  "    public void firstEntry() {\n"  +  "	// The first node is a sentinel so the first entry is in the 2nd node\n"  +  "	cursorNode_ = theListNode_.getNextNode();\n"  +  "    }\n"  +  "    public /*@ pure @*/ boolean isOffEnd() {\n"  +  "	return cursorNode_ == lastNode_;\n"  +  "    }\n"  +  "\n"  +  "    public void incrementCursor() {\n"  +  "	if (isOffEnd()) {\n"  +  "	    // System.err.println(\"Error in `DLList.incrementCursor()': No more List entries\");\n"  +  "	    throw new IllegalStateException(\"Error in `DLList.incrementCursor()': No more List entries\");\n"  +  "	}\n"  +  "	cursorNode_ = cursorNode_.getNextNode();\n"  +  "    }\n"  +  "\n"  +  "    /*@ non_null @*/ public Object getEntry() {\n"  +  "	if (isOffEnd()) {\n"  +  "	    // The following line is not pure\n"  +  "	    //System.err.println(\"Error in `DLList.getEntry': cursorNode_ is invalid\");\n"  +  "	    throw new IllegalStateException(\"Error in `DLList.getEntry': cursorNode_ is invalid\");\n"  +  "	}\n"  +  "	return(cursorNode_.getEntry());\n"  +  "    }\n"  +  "\n"  +  "    // NEW iteration methods (for doubly linked list)\n"  +  "    // ---------------------\n"  +  "    public void decrementCursor() {\n"  +  "	if (isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `DLList.decrementCursor': cursorNode_ is invalid\");\n"  +  "	    throw new IllegalStateException(\"Error in `DLList.decrementCursor': cursorNode_ is invalid\");\n"  +  "	}\n"  +  "	cursorNode_ = ((DLNode)cursorNode_).getPrevNode();\n"  +  "	// super.decreaseCursor();\n"  +  "    }\n"  +  "    public void lastEntry() {\n"  +  "	// lastNode_ points to sentinel node at end of list.\n"  +  "	// So the node previous to the last sentinel node is the last node.\n"  +  "\n"  +  "	cursorNode_ = lastNode_;\n"  +  "	decrementCursor();\n"  +  "    }\n"  +  "    public void removeEntry() {\n"  +  "	if (isOffEnd() || isOffFront()) {\n"  +  "	    // System.err.println(\"Error in `DLList.removeEntry': cursorNode_ is invalid\");\n"  +  "	    throw new IllegalStateException(\"Error in `DLList.removeEntry': cursorNode_ is invalid\");\n"  +  "	}\n"  +  "\n"  +  "	DLNode prev1 = ((DLNode)cursorNode_).getPrevNode();\n"  +  "\n"  +  "	// link the previous node to the next node\n"  +  "	// link the next node back to the previous node\n"  +  "	prev1.removeNextNode();\n"  +  "\n"  +  "	cursorNode_ = prev1;\n"  +  "	length_ --;\n"  +  "	log_++;\n"  +  "    }\n"  +  "    public void insertAfterCursor(Object newEntry) {\n"  +  "	DLNode origCursor = (DLNode)cursorNode_;\n"  +  "\n"  +  "	if (!isOffEnd()) {\n"  +  "	    incrementCursor();\n"  +  "	}\n"  +  "\n"  +  "	insertBeforeCursor(newEntry);\n"  +  "	cursorNode_ = origCursor;\n"  +  "    }\n"  +  "    public void insertBeforeCursor(Object newEntry) {\n"  +  "	DLNode origCursor = (DLNode)cursorNode_;\n"  +  "\n"  +  "	if (isOffFront()) {\n"  +  "	    incrementCursor();\n"  +  "	} \n"  +  "\n"  +  "	((DLNode)cursorNode_).insertBefore(newEntry);\n"  +  "\n"  +  "	cursorNode_ = origCursor;\n"  +  "	log_++;\n"  +  "	length_ ++;\n"  +  "    }\n"  +  "    public /*@ non_null @*/ Object clone() {\n"  +  "	DLList result = new DLList( (DLNode) theListNode_.clone(),\n"  +  "				    length_ );\n"  +  "	return result;\n"  +  "    }\n"  +  "    public /*@ non_null @*/ String toString() {\n"  +  "	String str = \"<\";\n"  +  "	if (isOffEnd()) {\n"  +  "	    if (theListNode_.getNextNode() != null) {\n"  +  "		str += theListNode_.getNextNode().toString();\n"  +  "	    }\n"  +  "	    str += \" || \";\n"  +  "	} else {\n"  +  "	    str += cursorNode_.toString();\n"  +  "	}\n"  +  "	str += \">\";\n"  +  "	return str;\n"  +  "    }\n"  +  "\n"  +  "    // ***********************************************************\n"  +  "    // protected methods\n"  +  "\n"  +  "    protected DLList(DLList othLst) {\n"  +  "	theListNode_ = (DLNode) othLst.theListNode_;\n"  +  "	length_ = othLst.length_;\n"  +  "	log_ = othLst.log_;\n"  +  "	lastNode_ = othLst.lastNode_;\n"  +  "\n"  +  "	// To satisfy the class invariant the \n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "	cursorNode_ = theListNode_;\n"  +  "\n"  +  "	firstEntry();\n"  +  "    }\n"  +  "\n"  +  "    protected DLList(DLNode listNode, int len) {\n"  +  "	theListNode_ = listNode;\n"  +  "	length_ = len;\n"  +  "	log_ = 0;\n"  +  "	SLNode currNode = listNode;\n"  +  "	while (currNode.getNextNode() != null) {\n"  +  "	    currNode = currNode.getNextNode();\n"  +  "	}\n"  +  "	lastNode_ = (DLNode) currNode;\n"  +  "\n"  +  "	// To satisfy the class invariant the \n"  +  "	// model field 'cursor' needs a valid value before the call!\n"  +  "	cursorNode_ = theListNode_;\n"  +  "	firstEntry();\n"  +  "}\n"  )  ; 

